// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

use crate::{
    error::{ConnectionError, Error},
    runtime::Runtime,
    sam::{
        parser::{SamCommand, SamVersion},
        socket::SamSocket,
    },
};

use futures::{future::BoxFuture, FutureExt, StreamExt};
use hashbrown::HashMap;

use alloc::{boxed::Box, format, string::String};
use core::{
    future::Future,
    pin::Pin,
    task::{Context, Poll},
    time::Duration,
};

/// Logging target for the file.
const LOG_TARGET: &str = "emissary::sam::pending";

/// Minimum supported version of SAMv3.
const MIN_SAMV3_VERSION: SamVersion = SamVersion::V31;

/// Maximum supported version of SAMv3.
const MAX_SAMV3_VERSION: SamVersion = SamVersion::V33;

/// Keep-alive timeout.
const KEEP_ALIVE_TIMEOUT: Duration = Duration::from_secs(10);

/// Session kind.
///
/// NOTE: `Datagram` and `Anonymous` are currently unsupported
pub enum SessionKind {
    /// Streaming.
    Stream,

    /// Repliable datagram.
    Datagram,

    /// Anonymous datagrams.
    Anonymous,
}

/// SAMv3 connection kind.
pub enum ConnectionKind<R: Runtime> {
    /// Create new session.
    Session {
        /// TCP stream associated with the session.
        stream: R::TcpStream,

        /// Negotiated version.
        version: SamVersion,

        /// Session ID, generated by the client.
        session_id: String,

        /// Session kind.
        session_kind: SessionKind,

        /// Session options.
        options: HashMap<String, String>,
    },

    /// Open virtual stream to `destination` over this connection.
    Stream {
        /// TCP stream associated with the outbound stream.
        stream: R::TcpStream,

        /// Negotiated version.
        version: SamVersion,

        /// Destination.
        destination: String,

        /// Options.
        options: HashMap<String, String>,
    },

    /// Accept inbond virtual stream over this connection.
    Accept {
        /// TCP stream associated with the inbound stream.
        stream: R::TcpStream,

        /// Negotiated version.
        version: SamVersion,

        /// Options.
        options: HashMap<String, String>,
    },

    /// Forward incoming virtual streams to a TCP listener listening to `port`.
    Forward {
        /// TCP stream associated with forwarding.
        stream: R::TcpStream,

        /// Negotiated version.
        version: SamVersion,

        /// Port which the TCP listener is listening.
        port: u16,
    },
}

/// Connection state.
///
/// Connection starts by the client and server agreeing on a SAMv3 version after which the client
/// sends one of four commands:
///  - `SESSION CREATE`
///  - `STREAM CONNECT`
///  - `STREAM ACCEPT`
///  - `STREAM FORWARD`
///
/// [`PendingSamConnection`] doesn't validate the command, apart from checking that it's a valid
/// SAMv3 command and leaves the validation of the command with respect to the overall connection
/// state to `SamServer` which ensures that for stream-related commands, there exists an active
/// session.
#[derive(Debug)]
enum PendingConnectionState {
    /// Awaiting handshake from client.
    AwaitingHandshake,

    /// Session has been handshaked.
    Handshaked {
        /// Negotiated SAMv3 version.
        version: SamVersion,
    },
}

/// Pending SAMv3 connection.
///
/// Session can be one of four kinds:
///  - new session
///  - new outbound virtual stream
///  - new inbound virtual stream
///  - forwarding request
///
/// The last three kinds require there to be an active session.
pub struct PendingSamConnection<R: Runtime> {
    /// Socket used to read SAMv3 commands from client.
    socket: SamSocket<R>,

    /// Connection state.
    state: PendingConnectionState,

    /// Keep-alive timer.
    keep_alive_timer: BoxFuture<'static, ()>,
}

impl<R: Runtime> PendingSamConnection<R> {
    /// Create new [`PendingSamConnection`].
    pub fn new(stream: R::TcpStream) -> Self {
        Self {
            socket: SamSocket::new(stream),
            state: PendingConnectionState::AwaitingHandshake,
            keep_alive_timer: Box::pin(R::delay(KEEP_ALIVE_TIMEOUT)),
        }
    }
}

impl<R: Runtime> Future for PendingSamConnection<R> {
    type Output = crate::Result<ConnectionKind<R>>;

    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        loop {
            match (self.socket.poll_next_unpin(cx), &self.state) {
                (Poll::Pending, _) => break,
                (Poll::Ready(None), _) => {
                    tracing::debug!(
                        target: LOG_TARGET,
                        "client closed socket",
                    );
                    return Poll::Ready(Err(Error::Connection(ConnectionError::SocketClosed)));
                }
                (
                    Poll::Ready(Some(SamCommand::Hello { min, max })),
                    &PendingConnectionState::AwaitingHandshake,
                ) => {
                    // default to client's maximum supported version and if they didn't provide
                    // a version, default to server's maximum supported version which is SAMv3.3
                    let version = max.unwrap_or(SamVersion::V33);

                    tracing::debug!(
                        target: LOG_TARGET,
                        ?version,
                        "client connected"
                    );

                    self.socket.send_message(
                        format!("HELLO REPLY RESULT=OK VERSION={version}\n").as_bytes().to_vec(),
                    );
                    self.state = PendingConnectionState::Handshaked { version };

                    // reset keep-alive timeout so the client has another 10 seconds to send the
                    // next command before the connection is closed
                    self.keep_alive_timer = Box::pin(R::delay(KEEP_ALIVE_TIMEOUT));
                }
                (Poll::Ready(Some(SamCommand::Hello { min, max })), state) => {
                    tracing::warn!(
                        target: LOG_TARGET,
                        ?min,
                        ?max,
                        ?state,
                        "invalid state to receive `HELLO`",
                    );
                    return Poll::Ready(Err(Error::InvalidState));
                }
            }
        }

        if let Poll::Ready(_) = self.keep_alive_timer.poll_unpin(cx) {
            return Poll::Ready(Err(Error::Connection(ConnectionError::KeepAliveTimeout)));
        }

        Poll::Pending
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::runtime::{
        mock::{MockRuntime, MockTcpStream},
        TcpStream as _,
    };
    use futures::StreamExt;
    use std::time::Duration;
    use tokio::{
        io::{AsyncBufReadExt, AsyncWriteExt, BufReader},
        net::{TcpListener, TcpStream},
    };

    #[tokio::test]
    async fn client_closes_socket() {
        let listener = TcpListener::bind("127.0.0.1:0").await.unwrap();
        let address = listener.local_addr().unwrap();
        let (stream1, stream2) = tokio::join!(listener.accept(), MockTcpStream::connect(address));

        stream1.unwrap().0.shutdown();

        match PendingSamConnection::<MockRuntime>::new(stream2.unwrap()).await {
            Err(Error::Connection(ConnectionError::SocketClosed)) => {}
            _ => panic!("invalid result"),
        }
    }

    #[tokio::test]
    async fn keep_alive_timeout() {
        let listener = TcpListener::bind("127.0.0.1:0").await.unwrap();
        let address = listener.local_addr().unwrap();
        let (stream1, stream2) = tokio::join!(listener.accept(), MockTcpStream::connect(address));

        match PendingSamConnection::<MockRuntime>::new(stream2.unwrap()).await {
            Err(Error::Connection(ConnectionError::KeepAliveTimeout)) => {}
            _ => panic!("invalid result"),
        }
    }

    #[tokio::test]
    async fn keep_alive_timeout_after_handshake() {
        let listener = TcpListener::bind("127.0.0.1:0").await.unwrap();
        let address = listener.local_addr().unwrap();
        let (stream1, stream2) = tokio::join!(listener.accept(), MockTcpStream::connect(address));

        let mut connection = PendingSamConnection::<MockRuntime>::new(stream2.unwrap());
        let mut stream = stream1.unwrap().0;

        // send handshake
        stream.write_all(b"HELLO VERSION\n").await.unwrap();

        // poll pending connection until it's handshaked
        loop {
            futures::future::poll_fn(|cx| match connection.poll_unpin(cx) {
                Poll::Pending => Poll::Ready(()),
                _ => panic!("invalid return value"),
            })
            .await;

            match connection.state {
                PendingConnectionState::Handshaked {
                    version: SamVersion::V33,
                } => break,
                _ => {}
            }

            tokio::time::sleep(Duration::from_secs(1)).await;
        }

        // read and validate handshake response
        let mut reader = BufReader::new(stream);
        let mut response = String::new();
        reader.read_line(&mut response).await.unwrap();

        assert_eq!(response, "HELLO REPLY RESULT=OK VERSION=3.3\n");

        // verify connection times out
        match connection.await {
            Err(Error::Connection(ConnectionError::KeepAliveTimeout)) => {}
            _ => panic!("invalid result"),
        }
    }

    #[tokio::test]
    async fn client_requests_no_version() {
        let listener = TcpListener::bind("127.0.0.1:0").await.unwrap();
        let address = listener.local_addr().unwrap();
        let (stream1, stream2) = tokio::join!(listener.accept(), MockTcpStream::connect(address));

        let mut connection = PendingSamConnection::<MockRuntime>::new(stream2.unwrap());
        let mut stream = stream1.unwrap().0;

        // send handshake
        stream.write_all(b"HELLO VERSION\n").await.unwrap();

        // poll pending connection until it's handshaked
        loop {
            futures::future::poll_fn(|cx| match connection.poll_unpin(cx) {
                Poll::Pending => Poll::Ready(()),
                _ => panic!("invalid return value"),
            })
            .await;

            match connection.state {
                PendingConnectionState::Handshaked {
                    version: SamVersion::V33,
                } => break,
                _ => {}
            }

            tokio::time::sleep(Duration::from_secs(1)).await;
        }

        // read and validate handshake response
        let mut reader = BufReader::new(stream);
        let mut response = String::new();
        reader.read_line(&mut response).await.unwrap();

        assert_eq!(response, "HELLO REPLY RESULT=OK VERSION=3.3\n");
    }

    #[tokio::test]
    async fn client_requests_max_version() {
        let listener = TcpListener::bind("127.0.0.1:0").await.unwrap();
        let address = listener.local_addr().unwrap();
        let (stream1, stream2) = tokio::join!(listener.accept(), MockTcpStream::connect(address));

        let mut connection = PendingSamConnection::<MockRuntime>::new(stream2.unwrap());
        let mut stream = stream1.unwrap().0;

        // send handshake
        stream.write_all(b"HELLO VERSION MAX=3.2\n").await.unwrap();

        // poll pending connection until it's handshaked
        loop {
            futures::future::poll_fn(|cx| match connection.poll_unpin(cx) {
                Poll::Pending => Poll::Ready(()),
                _ => panic!("invalid return value"),
            })
            .await;

            match connection.state {
                PendingConnectionState::Handshaked {
                    version: SamVersion::V32,
                } => break,
                _ => {}
            }

            tokio::time::sleep(Duration::from_secs(1)).await;
        }

        // read and validate handshake response
        let mut reader = BufReader::new(stream);
        let mut response = String::new();
        reader.read_line(&mut response).await.unwrap();

        assert_eq!(response, "HELLO REPLY RESULT=OK VERSION=3.2\n");
    }

    #[tokio::test]
    async fn client_requests_min_version() {
        let listener = TcpListener::bind("127.0.0.1:0").await.unwrap();
        let address = listener.local_addr().unwrap();
        let (stream1, stream2) = tokio::join!(listener.accept(), MockTcpStream::connect(address));

        let mut connection = PendingSamConnection::<MockRuntime>::new(stream2.unwrap());
        let mut stream = stream1.unwrap().0;

        // send handshake
        stream.write_all(b"HELLO VERSION MIN=3.1\n").await.unwrap();

        // poll pending connection until it's handshaked
        loop {
            futures::future::poll_fn(|cx| match connection.poll_unpin(cx) {
                Poll::Pending => Poll::Ready(()),
                _ => panic!("invalid return value"),
            })
            .await;

            match connection.state {
                PendingConnectionState::Handshaked {
                    version: SamVersion::V33,
                } => break,
                _ => {}
            }

            tokio::time::sleep(Duration::from_secs(1)).await;
        }

        // read and validate handshake response
        let mut reader = BufReader::new(stream);
        let mut response = String::new();
        reader.read_line(&mut response).await.unwrap();

        assert_eq!(response, "HELLO REPLY RESULT=OK VERSION=3.3\n");
    }
}
